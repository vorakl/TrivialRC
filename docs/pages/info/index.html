<!DOCTYPE html><html lang=en> <head><meta charset=utf-8><title>The minimalistic Run-time Configuration (RC) system and process manager :: TrivialRC</title><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=robots content=all><link href=https://trivialrc.vorakl.com/pages/info/ rel=canonical><meta name=description content="The minimalistic Run-time Configuration (RC) system and process manager"><!--[if lt IE 9]>
    <script src="https://trivialrc.vorakl.com/theme/html5.js?v=1494021628"></script>
    <![endif]--><link rel=stylesheet href="https://trivialrc.vorakl.com/theme/bootstrap-pygments.bundle.min.css?v=1494021628"><link rel="shortcut icon" href="/favicon.ico?v=1494021628"><meta name=apple-mobile-web-app-title content=TrivialRC><meta name=application-name content=TrivialRC></head> <body> <div class=navbar> <div class=navbar-inner> <div class=container> <a href=https://trivialrc.vorakl.com/ class=brand>TrivialRC</a> <a class="btn btn-navbar" data-toggle=collapse data-target=.nav-collapse> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span> </a> <div class=nav-collapse> <ul class="nav pull-right"> <!-- <li class="divider-vertical"></li> --> <li><a href=https://github.com/vorakl/TrivialRC>repo</a></li> <li><a href=https://vorakl.com/ >blog</a></li> <li><a href=https://vorakl.com/pages/about/ >author</a></li> <!-- <li class="divider-vertical"></li> --> </ul> </div> </div> </div> </div> <div class=container> <div class=content> <div class=row> <div class=span12> <div class=article> <div class=content-title> <h2>The minimalistic Run-time Configuration (RC) system and process manager</h2> <div class="well small">The minimalistic Run-time Configuration (RC) system and process manager</div> </div> <div><p><a class="reference external" href=https://travis-ci.org/vorakl/TrivialRC><img alt="Travis CI: continuous integration status" src="https://travis-ci.org/vorakl/TrivialRC.svg?branch=master"></a></p> <ul class=simple> <li><a class="reference internal" href=#introduction>Introduction</a></li> <li><dl class="first docutils"> <dt><a class="reference internal" href=#installation>Installation</a></dt> <dd><ul class="first last"> <li><a class="reference internal" href=#the-installation-on-top-of-centos-linux-base-image>The installation on top of CentOS Linux base image</a></li> <li><a class="reference internal" href=#the-installation-on-top-of-alpine-linux-base-image>The installation on top of Alpine Linux base image</a></li> </ul> </dd> </dl> </li> <li><a class="reference internal" href=#how-to-get-started>How to get started?</a></li> <li><a class="reference internal" href=#command-line-options>Command line options</a></li> <li><a class="reference internal" href=#run-stages>Run stages</a></li> <li><a class="reference internal" href=#wait-policies>Wait policies</a></li> <li><a class="reference internal" href=#verbose-levels>Verbose levels</a></li> <li><a class="reference internal" href=#integrated-functions>Integrated functions</a></li> <li><a class="reference internal" href=#useful-global-variables>Useful global variables</a></li> </ul> <div class=section id=introduction> <h2>Introduction</h2> <p>The minimalistic Run-time Configuration (RC) system and process manager is written in pure BASH and uses just a few external utilities like <tt class="docutils literal">ls</tt>, <tt class="docutils literal">ps</tt>, <tt class="docutils literal">date</tt> and <tt class="docutils literal">sleep</tt>. Minimally, installation of TrivialRC consists of only one file which can be downloaded directly from the Github. Originaly, it was designed for use in containers but it also can be well used for running a group of processes asynchronously and synchronously, as well as managing their running order and exit codes.</p> <p>TrivialRC is not a replacement for an init process that usually resides in <tt class="docutils literal">/sbin/init</tt> and has a PID 1. In containers for this purpose projects like <a class="reference external" href=https://github.com/Yelp/dumb-init>dumb-init</a> or <a class="reference external" href=https://github.com/krallin/tini>tini</a> can be used, although in most cases, having only TrivialRC as a first/main process (PID 1) in containers is quite enough. In terms of Docker, the best place for it is ENTRYPOINT.</p> <p>TrivialRC is an equivalent to well known <tt class="docutils literal">/etc/rc</tt> for xBSD users. The RC system that is used for managing startup and shutdown processes. It can start and stop one or more processes, in parallel or sequentially, on back- or foreground, react differently in case of process failures, etc. All commands can be specified in the command line if they are relatively simple, or in separate files if a more comprehensive scenario is needed. That's why it can be used as a simplest tool for managing a group of process and be a lightweight replacement for solutions like <a class="reference external" href=https://github.com/Supervisor/supervisor>Supervisor</a>.</p> <p>For instance, in docker images when TrivialRC is used as an Entrypoint, it doesn't reveal itself by default, does not affect any configuration and behaves absolutely transparently. So, you can add it into any Dockerfiles which do not have an entrypoint yet and get by this the full control under processes with fairly detailed logs of what's is going on inside a container. Please, take a look at <a class="reference external" href=https://github.com/vorakl/TrivialRC/tree/master/examples>examples</a> for more information.</p> </div> <div class=section id=installation> <h2>Installation</h2> <p>Basically, all you need to install TrivialRC is download the latest release of the script from <tt class="docutils literal"><span class=pre>http://trivialrc.vorakl.com/trc</span></tt> and give it an execute permission. By default, it looks for configuration files in the same directory from which it was invoked but this behavior can be changed by setting a work directory (<tt class="docutils literal"><span class=pre>-w|--workdir</span></tt> parametr). So, if you are going to use configuration files and keep them in <tt class="docutils literal">/etc/</tt>, then you would probably want to install the script to /etc/ as well and simply run it without specifying any parametrs.</p> <p>Another option in this case could be to install the script in a more appropriate path but don't forget to specify <tt class="docutils literal"><span class=pre>--workdir</span> /etc</tt> parametr every time when you invoke this rc system. Both options are possible and depend more on a particular use case. For instance, in case of using in a docker container, I personaly prefer to have all configuration in separate files in <tt class="docutils literal">trc.d/</tt> sub-directory and copy it together with the script in <tt class="docutils literal">/etc/</tt>.</p> <div class=section id=the-installation-on-top-of-centos-linux-base-image> <h3>The installation on top of CentOS Linux base image</h3> <p>This is an example of how it would look in a Dockerfile with <a href=https://hub.docker.com/_/centos/ class="reference external">centos:latest</a> as base image:</p> <div class=highlight><pre><span></span>FROM centos:latest

RUN curl -sSLfo /etc/trc http://trivialrc.vorakl.com/trc <span class=o>&amp;&amp;</span> <span class=se>\</span>
    <span class=o>(</span> <span class=nb>cd</span> /etc <span class=o>&amp;&amp;</span> curl -sSLf http://trivialrc.vorakl.com/trc.sha256 <span class=p>|</span> sha256sum -c <span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=se>\</span>
    chmod +x /etc/trc <span class=o>&amp;&amp;</span> <span class=se>\</span>
    /etc/trc --version

<span class=c1># Uncomment this if you have configuration files in trc.d/</span>
<span class=c1># COPY trc.d/ /etc/trc.d/</span>

ENTRYPOINT <span class=o>[</span><span class=s2>&quot;/etc/trc&quot;</span><span class=o>]</span>
</pre></div> </div> <div class=section id=the-installation-on-top-of-alpine-linux-base-image> <h3>The installation on top of Alpine Linux base image</h3> <p><strong>Attention</strong>! The Alpine Linux comes with Busybox but its functionality as a shell and as a few emulated tools <tt class="docutils literal">is not enough</tt> for TrivialRC. To work in this distribution it requires two extra packages: <tt class="docutils literal">bash</tt> and <tt class="docutils literal">procps</tt>. As a result, Dockerfile for the <a href=https://hub.docker.com/_/alpine/ class="reference external">alpine:latest</a> base image would look like:</p> <div class=highlight><pre><span></span>FROM alpine:latest

RUN apk add --no-cache bash procps

RUN wget -qP /etc/ http://trivialrc.vorakl.com/trc <span class=o>&amp;&amp;</span> <span class=se>\</span>
    <span class=o>(</span> <span class=nb>cd</span> /etc <span class=o>&amp;&amp;</span> wget -qO - http://trivialrc.vorakl.com/trc.sha256 <span class=p>|</span> sha256sum -c <span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=se>\</span>
    chmod +x /etc/trc <span class=o>&amp;&amp;</span> <span class=se>\</span>
    /etc/trc --version

<span class=c1># Uncomment this if you have configuration files in trc.d/</span>
<span class=c1># COPY trc.d/ /etc/trc.d/</span>

ENTRYPOINT <span class=o>[</span><span class=s2>&quot;/etc/trc&quot;</span><span class=o>]</span>
</pre></div> </div> </div> <div class=section id=how-to-get-started> <h2>How to get started?</h2> <p>To get started and find out some features, basically, I suggest to go through <a class="reference external" href=https://github.com/vorakl/TrivialRC/tree/master/examples>all available examples</a> and read their readmes plus comments along the code but to start from <a class="reference external" href=https://github.com/vorakl/TrivialRC/blob/master/examples/one-liners>one-liners</a> which show most common use cases and features.</p> </div> <div class=section id=command-line-options> <h2>Command line options</h2> <p>It is important to notice that the order of command line options <strong>is not</strong> equal to their run order. In general it looks like:</p> <div class=highlight><pre><span></span>$ trc <span class=o>[</span>-h<span class=p>|</span>--help<span class=o>]</span> <span class=o>[</span>-v<span class=p>|</span>--version<span class=o>]</span> <span class=o>[</span>-w<span class=p>|</span>--workdir <span class=s1>&#39;dir&#39;</span><span class=o>]</span> <span class=o>[</span>-B <span class=s1>&#39;cmds&#39;</span> <span class=o>[</span>...<span class=o>]]</span> <span class=o>[</span>-H <span class=s1>&#39;cmds&#39;</span> <span class=o>[</span>...<span class=o>]]</span> <span class=o>[</span>-D <span class=s1>&#39;cmds&#39;</span> <span class=o>[</span>...<span class=o>]]</span> <span class=o>[</span>-F <span class=s1>&#39;cmds&#39;</span> <span class=o>[</span>...<span class=o>]]</span> <span class=o>[</span><span class=nb>command</span> <span class=o>[</span>args<span class=o>]]</span>
</pre></div> <p>Where</p> <ul class=simple> <li><tt class="docutils literal"><span class=pre>-h</span></tt> or <tt class="docutils literal"><span class=pre>--help</span></tt>, prints a short help message</li> <li><tt class="docutils literal"><span class=pre>-v</span></tt> or <tt class="docutils literal"><span class=pre>--version</span></tt>, prints a current version</li> <li><tt class="docutils literal"><span class=pre>-w</span> 'directory'</tt> or <tt class="docutils literal"><span class=pre>--workdir</span> 'directory'</tt>, sets a location with configuration files</li> <li><tt class="docutils literal"><span class=pre>-B</span> 'command1; command2; <span class=pre>...'</span></tt>, boot commands</li> <li><tt class="docutils literal"><span class=pre>-H</span> 'command1; command2; <span class=pre>...'</span></tt>, halt commands</li> <li><tt class="docutils literal"><span class=pre>-D</span> 'command1; command2; <span class=pre>...'</span></tt>, async commands</li> <li><tt class="docutils literal"><span class=pre>-F</span> 'command1; command2; <span class=pre>...'</span></tt>, sync commands</li> <li><tt class="docutils literal">command [args]</tt>, a sync command</li> </ul> <p>So, command line options have to be supplied in the next order</p> <ol class="arabic simple"> <li><tt class="docutils literal"><span class=pre>-B</span></tt>, zero or more</li> <li><tt class="docutils literal"><span class=pre>-H</span></tt>, zero or more</li> <li><tt class="docutils literal"><span class=pre>-D</span></tt>, zero or more</li> <li><tt class="docutils literal"><span class=pre>-F</span></tt>, zero or more</li> <li><tt class="docutils literal">command with arguments</tt> (without an option), zero or only one</li> </ol> <p>Examples:</p> <div class=highlight><pre><span></span>$ trc -B <span class=s1>&#39;name=$(id -un); echo booting...&#39;</span> -H <span class=s1>&#39;echo halting...&#39;</span> -F <span class=s1>&#39;echo Hello, ${name}!&#39;</span>

$ <span class=nv>RC_WAIT_POLICY</span><span class=o>=</span>wait_all trc -D <span class=s1>&#39;echo Hello&#39;</span> -D <span class=s1>&#39;sleep 2; echo World&#39;</span> <span class=nb>echo</span> waiting...

$ <span class=nv>RC_VERBOSE</span><span class=o>=</span><span class=nb>true</span> trc -F <span class=s1>&#39;echo -n &quot;Hello &quot;; echo World&#39;</span>

$ trc --workdir /opt/app
</pre></div> </div> <div class=section id=run-stages> <h2>Run stages</h2> <p>The life cycle of TrivialRC consists of different stages, with different isolation. By default, all configuration files (or trc.d/ directory with them) are searched in the directory from which was executed <tt class="docutils literal">trc</tt> itself. For instance, if you've installed trc in /usr/bin/ and run it by using only its name, like <tt class="docutils literal">trc</tt>, then configuration will also be searched in /usr/bin/. Though, you can place configuration files anywhere you like and specify their location in the <tt class="docutils literal"><span class=pre>-w|--workdir</span></tt> option, like <tt class="docutils literal">trc <span class=pre>-w</span> /etc/</tt>.</p> <p>Let's check:</p> <div class=highlight><pre><span></span>$ which trc
/usr/bin/trc

$ trc -B <span class=s1>&#39;echo $dir_name&#39;</span>
/usr/bin

$ trc -w /etc -B <span class=s1>&#39;echo $dir_name&#39;</span>
/etc
</pre></div> <p>All stages are executed through in the next order:</p> <ol class=arabic> <li><dl class="first docutils"> <dt><tt class="docutils literal">boot</tt></dt> <dd><p class=first><strong>Execution order</strong>: trc.boot.* -&gt; trc.d/boot.* -&gt; [-B 'cmds' [...]]</p> <p class=last>Commands run in a same environment as the main process and that's why it has to be used with caution. It's useful for setting up global variables which are seen in all other isolated environments.</p> </dd> </dl> </li> <li><dl class="first docutils"> <dt><tt class="docutils literal">async</tt></dt> <dd><p class=first><strong>Execution order</strong>: trc.async.* -&gt; trc.d/async.* -&gt; [-D 'cmds' [...]]</p> <p>Commands run in the separate environment, asynchronously (all run in parallel), in the background and do not affect the main process. If you are going to run more than one async commands, don't forget that default RC_WAIT_POLICY is set to 'wait_any' and the executing process will be stopped after the first finished command and only if there wasn't any running foreground (sync) command that could block the reaction on the TERM signal. So, there are two options:</p> <ul class="last simple"> <li>to wait until all async commands have finished, you need to set RC_WAIT_POLICY to 'wait_all'.</li> <li>to wait for the first finished command, do not change the default value of RC_WAIT_POLICY but run only async commands.</li> </ul> </dd> </dl> </li> <li><dl class="first docutils"> <dt><tt class="docutils literal">sync</tt></dt> <dd><p class=first><strong>Execution order</strong>: trc.sync.* -&gt; trc.d/sync.* -&gt; [-F 'cmds' [...]] -&gt; [cmd]</p> <p class=last>Commands run in the separate environment, synchronously (one by one), in the foreground and do not affect the main process. if you are going to run more than one sync commands, don't forget to change RC_WAIT_POLICY to 'wait_all' or 'wait_err', otherwise, the executing process will be stopped after the first command.</p> </dd> </dl> </li> <li><dl class="first docutils"> <dt><tt class="docutils literal">halt</tt></dt> <dd><p class=first><strong>Execution order</strong>: trc.halt.* -&gt; trc.d/halt.* -&gt; [-H 'cmds' [...]]</p> <p class=last>Commands run in the separate environment, synchronously (one by one) when the main process is finishing (on exit). An exit status from the last halt command has precedence under an exit status from the main process which was supplied as ${_exit_status} variable. So you are able to keep a main exit status (by finishing as <strong>exit ${_exit_status}</strong>) or rewrite it to something else but anyway, if you have at least one halt command, TrivialRC will finish with an exit status of this halt command.</p> </dd> </dl> </li> </ol> </div> <div class=section id=wait-policies> <h2>Wait policies</h2> <p>The rc system reacts differently when one of controlled processes finishes. Depending on the value of <strong>RC_WAIT_POLICY</strong> environment variable it makes a decision when exactly it should stop itself. The possible values are:</p> <ul class=simple> <li><dl class="first docutils"> <dt><tt class="docutils literal">wait_all</tt></dt> <dd>stops after exiting all commands and it doesn't matter whether they are synchronous or asynchronous. Just keep in mind, if you need to catch a signal in the main process, it doesn't have to be blocked by some foreground (sync) process. For example, this mode can be helpful if you need to troubleshoot a container (with <cite>wait_any</cite> policy) where some async task fails and the whole container gets stopped by this immediately. In this case, you can change a policy to <cite>wait_all</cite> and run BASH in the foreground like <tt class="docutils literal">docker <span class=pre>-e</span> RC_WAIT_POLICY=wait_all <span class=pre>some-container</span> bash</tt></dd> </dl> </li> <li><dl class="first docutils"> <dt><tt class="docutils literal">wait_any</tt> [default]</dt> <dd>stops after exiting any of background commands and if there are no foreground commands working at that moment. It makes sense to use this mode if all commands are <strong>asynchronous</strong> (background). For example, if you need to start more than one process in the docker container, they all have to be asynchronous. Then, the main processed will be able to catch signals (for instance, from a docker daemon) and wait for finishing all other async processes.</dd> </dl> </li> <li><dl class="first docutils"> <dt><tt class="docutils literal">wait_err</tt></dt> <dd>stops after the first failed command. It make sense to use this mode with <strong>synchronous</strong> (foreground) commands only. For example, if you need to iterate sequentially over the list of commands and to stop only if one of them has failed.</dd> </dl> </li> <li><dl class="first docutils"> <dt><tt class="docutils literal">wait_forever</tt></dt> <dd>there is a special occasion when a process has doubled forked to become a daemon, it's still running but for the parent shell such process is considered as finished. So, in this mode, TrivialRC will keep working even if all processes have finished and it has to be stopped by the signal from its parent process (such as docker daemon for example).</dd> </dl> </li> </ul> </div> <div class=section id=verbose-levels> <h2>Verbose levels</h2> <p>By default, TrivailRC doesn't print any service messages at all. It only sends <tt class="docutils literal">stdout</tt> and <tt class="docutils literal">stderr</tt> of all isolated sub-shells to the same terminal. If another behavior is needed, you can redirect any of them inside each sub-shell separately. To increase the verbosity of rc system there are provided a few environment variables:</p> <ul class=simple> <li><dl class="first docutils"> <dt><tt class="docutils literal">RC_DEBUG</tt> (true|false) [false]</dt> <dd>Prints out all commands which are being executed</dd> </dl> </li> <li><dl class="first docutils"> <dt><tt class="docutils literal">RC_VERBOSE</tt> (true|false) [false]</dt> <dd>Prints out service information</dd> </dl> </li> <li><dl class="first docutils"> <dt><tt class="docutils literal">RC_VERBOSE_EXTRA</tt> (true|false) [false]</dt> <dd>Prints out additional service information</dd> </dl> </li> </ul> </div> <div class=section id=integrated-functions> <h2>Integrated functions</h2> <p>You can also use some of internal functions in async/sync tasks:</p> <ul class=simple> <li><dl class="first docutils"> <dt><tt class="docutils literal">say</tt></dt> <dd>prints only if RC_VERBOSE is set</dd> </dl> </li> <li><dl class="first docutils"> <dt><tt class="docutils literal">log</tt></dt> <dd>does the same as <tt class="docutils literal">say</tt> but add additional info about time, PID, namespace, etc</dd> </dl> </li> <li><dl class="first docutils"> <dt><tt class="docutils literal">warn</tt></dt> <dd>does the say as <tt class="docutils literal">log</tt> but sends a mesage to stderr</dd> </dl> </li> <li><dl class="first docutils"> <dt><tt class="docutils literal">err</tt></dt> <dd>does the same as <tt class="docutils literal">warn</tt> but exits with an error (exit status = 1)</dd> </dl> </li> <li><dl class="first docutils"> <dt><tt class="docutils literal">debug</tt></dt> <dd>does the same as <tt class="docutils literal">log</tt> but only if RC_VERBOSE_EXTRA is set</dd> </dl> </li> <li><dl class="first docutils"> <dt><tt class="docutils literal">run</tt></dt> <dd>launches builtin or external commands without checking functions with the same name For instance, if you wanna run only external command from the standart PATH list, use <tt class="docutils literal">run <span class=pre>-p</span> 'command'</tt> Or, if you need to check existence of the command, try <tt class="docutils literal">run <span class=pre>-v</span> 'command'</tt></dd> </dl> </li> </ul> </div> <div class=section id=useful-global-variables> <h2>Useful global variables</h2> <ul class=simple> <li><tt class="docutils literal">MAINPID</tt>, for sending signals to the main process (see <a class="reference external" href=https://github.com/vorakl/TrivialRC/tree/master/examples/reliable-tests-for-docker-images>Testing of Docker images</a>)</li> <li><tt class="docutils literal">_exit_status</tt>, for checking or rewriting an exit status of the whole script (see <a class="reference external" href=https://github.com/vorakl/TrivialRC/blob/master/examples/process-manager/trc.d/halt.remove-logs>Process Manager</a>, <a class="reference external" href=https://github.com/vorakl/TrivialRC/blob/master/examples/docker-service-discovery/trc.d/halt.sd-unreg>Service Discovery</a>)</li> </ul> <!-- Links --> </div> </div> </div> </div> </div> </div> <footer> <div class=container> <div class=row> <div class=span5> <span class=pull-left> &copy; 2020 <a href=https://vorakl.com/pages/about/ >Oleksii Tsvietnov</a> All Rights Reserved </span> </div> <div class=span7> <div class=pull-right> Powered by <a href=https://github.com/getpelican/pelican>Pelican</a> and <a href=https://github.com/vorakl/aves>Aves</a> theme </div> </div> </div> </div> </footer> </div> <script src="https://trivialrc.vorakl.com/theme/jquery-bootstrap-collapse.bundle.min.js?v=1494021628"></script> </body> </html>