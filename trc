#!/bin/bash

# TrivialRC
# The minimalistic RC system and process manager for containers and applications
# Copyright (c) 2016, 2017 by Oleksii Tsvietnov, me@vorakl.name
trc_version="1.2.1"

set +e # Do not exit on errors by default
if [[ "${RC_DEBUG}" = "true" ]]; then
    set -x # Turns on Debug mode
fi

main() {
    # Update $PATH at 'boot' stage to have extra paths if it's needed
    PATH="/sbin:/bin:/usr/sbin:/usr/bin"
    
    check_ver_usage "$1"
    check_req_bins ls ps kill pkill pgrep sleep date basename dirname tr

    # An exit status of a `halt` stage always has a priority against
    # main()'s exit status which is stored to ${main_exit_code}.
    # So, it's possible to exit from the last 'halt' command with ${main_exit_code}
    # or set to whatever you think is better as a final exit status.
    trap 'main_exit_code=$?;\
          trap "true" EXIT;\
          debug "exit-trap (exitcode=${main_exit_code})";\
          main_exit_hook' EXIT
    trap '_es_mt_er=$?;\
          trap "true" ERR;\
          if [[ "${RC_WAIT_POLICY}" = "wait_err" ]]; then\
              debug "err-trap (exitcode=${_es_mt_er})";\
              exit ${_es_mt_er};\
          fi' ERR
    trap '_es_mt_s=$?;\
          trap "true" HUP INT QUIT ILL TRAP ABRT BUS FPE USR1 SEGV\
                      USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS;\
          debug "sig-trap (exitcode=${_es_mt_s})";\
          exit ${_es_mt_s}' HUP INT QUIT ILL TRAP ABRT BUS FPE USR1 SEGV USR2\
                            PIPE ALRM TERM XCPU XFSZ VTALRM SYS

    local _wait_bg_cmd _file _es_m_f=0 _es_m_d=0

    export SELF_NAME=$(run -p basename $0 .sh) # Self name for logging
    export MAIN_PID="${BASHPID}" # PID of the main process
    : ${RC_WAIT_POLICY:=wait_any}; export RC_WAIT_POLICY 

    work_dir=$(run -p dirname $0)
    boot_stage_left=0
    halt_cmds_exist=0
    async_cmds_exist=0
    sync_cmds_exist=0
    halt_cmds=() # A list of 'halt' commands to be executed at the end
    sync_finished_cmds=() # In the order of their execution
    sync_finished_exitcodes=()
    async_finished_pids=()
    async_cmds_pids=()
    async_exitcodes_pids=()
    ns="main" # Name Space

    case "${RC_WAIT_POLICY}" in
        wait_all)  _wait_bg_cmd="run wait";;
        wait_any)  _wait_bg_cmd="run wait -n";;
        wait_err)  _wait_bg_cmd="run wait";;
        *)         _wait_bg_cmd=":";;
    esac

    log "The wait policy: ${RC_WAIT_POLICY}"

    if [[ "$1" = "-w" ]] || [[ "$1" = "--workdir" ]]; then
        shift
        work_dir="$1"
        shift
    fi

    debug "looking for 'boot' scripts and commands..."
    {
        # Reads commands from files to run before everything
        for _file in $(run -p ls ${work_dir}/trc.boot.* \
                              ${work_dir}/trc.d/boot.* 2>/dev/null || true); do
            log "Launching: ${_file}"
            set -e 
            . ${_file}
            set +e
        done

        # Checks for boot tasks in the command line.
        # All commands and their parameters should be supplied as one parameter!
        while [[ "$1" = "-B" ]]; do
            shift
            log "Launching: $1"
            set -e 
            eval "$1"
            set +e
            shift
        done
    }
    boot_stage_left=1

    debug "looking for 'halt' commands..."
    # Collects commands for the 'halt' stage from a command line to be run
    # on exit from the main exit trap
    while [[ "$1" = "-H" ]]; do
        shift
            halt_cmds_exist=1
            halt_cmds[${#halt_cmds[*]}]="$1"
        shift
    done

    debug "looking for 'async' scripts and commands..."
    # Reads commands from files to run in the background (in parallel)
    for _file in $(run -p ls ${work_dir}/trc.async.* \
                             ${work_dir}/trc.d/async.* 2>/dev/null || true); do
        async_cmds_exist=1
        (
            # Run this on any exit, catch the exitcode of the "main" command,
            # print additional info and finish this sub-program with
            # the right exitcode
            trap '_es_dt_ex=$?;\
                  trap "true" EXIT;\
                  debug "exit-trap (exitcode=${_es_dt_ex})";\
                  sub_exit_hook ${_es_dt_ex} "${_file}"' EXIT
            trap '_es_dt_er=$?;\
                  trap "true" ERR;\
                  debug "err-trap (exitcode=$_es_dt_er)";\
                  exit ${_es_dt_er}' ERR
            # In case of exit on errors (set -e) or by a signal, catch exitcode
            # and exit with it. This will lead to triggering an EXIT trap
            trap '_es_dt_s=$?;\
                  trap "true" HUP INT QUIT ILL TRAP ABRT BUS FPE USR1\
                              SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS;\
                  debug "sig-trap (exitcode=$_es_dt_s)";\
                  exit ${_es_dt_s}' HUP INT QUIT ILL TRAP ABRT BUS FPE USR1\
                                  SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS

            ns="async"
            log "Launching: ${_file}"
            . ${_file}
        )& 
        async_cmds_pids[$!]="${_file}"
    done

    # Checks for background tasks in the command line.
    # All commands and their parameters should be supplied as one parameter!
    while [[ "$1" = "-D" ]]; do
        shift
        async_cmds_exist=1
        (
            trap '_es_dt_ex=$?;\
                  trap "true" EXIT;\
                  debug "exit-trap (exitcode=${_es_dt_ex})";\
                  sub_exit_hook ${_es_dt_ex} "$1"' EXIT
            trap '_es_dt_er=$?;\
                  trap "true" ERR;\
                  debug "err-trap (exitcode=$_es_dt_er)";\
                  exit ${_es_dt_er}' ERR
            trap '_es_dt_s=$?;\
                  trap "true" HUP INT QUIT ILL TRAP ABRT BUS FPE USR1\
                              SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS;\
                  debug "sig-trap (exitcode=$_es_dt_s)";\
                  exit ${_es_dt_s}' HUP INT QUIT ILL TRAP ABRT BUS FPE USR1\
                                 SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS

            ns="async"
            log "Launching: $1"
            eval "$1"
        )& 
        async_cmds_pids[$!]="$1"
        shift
    done


    debug "looking for 'sync' scripts and commands..." 
    # Checks for foreground tasks in files (sequentially)
    for _file in $(run -p ls ${work_dir}/trc.sync.*\
                             ${work_dir}/trc.d/sync.* 2>/dev/null || true); do
        sync_cmds_exist=1
        (
            trap '_es_ft_ex=$?;\
                  trap "true" EXIT;\
                  debug "exit-trap (exitcode=${_es_ft_ex})";\
                  sub_exit_hook ${_es_ft_ex} "${_file}"' EXIT
            trap '_es_ft_er=$?;\
                  trap "true" ERR;\
                  debug "err-trap (exitcode=$_es_ft_er)";\
                  exit ${_es_ft_er}' ERR
            trap '_es_ft_s=$?;\
                  trap "true" HUP INT QUIT ILL TRAP ABRT BUS FPE USR1\
                              SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS;\
                  debug "sig-trap (exitcode=$_es_ft_s)";\
                  exit ${_es_ft_s}' HUP INT QUIT ILL TRAP ABRT BUS FPE USR1\
                                 SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS

            ns="sync"
            log "Launching: ${_file}"
            . ${_file}
        )
        # Catchs the exitcode of a foreground sub-shell
        _es_m_f=$?
    done

    # Checks for foreground tasks in the command line
    # All commands and their parameters should be supplied as one parameter!
    while [[ "$1" = "-F" ]]; do
        shift
        sync_cmds_exist=1
        (
            trap '_es_ft_ex=$?;\
                  trap "true" EXIT;\
                  debug "exit-trap (exitcode=${_es_ft_ex})";\
                  sub_exit_hook ${_es_ft_ex} "$1"' EXIT
            trap '_es_ft_er=$?;\
                  trap "true" ERR;\
                  debug "err-trap (exitcode=$_es_ft_er)";\
                  exit ${_es_ft_er}' ERR
            trap '_es_ft_s=$?;\
                  trap "true" HUP INT QUIT ILL TRAP ABRT BUS FPE USR1\
                              SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS;\
                  debug "sig-trap (exitcode=$_es_ft_s)";\
                  exit ${_es_ft_s}' HUP INT QUIT ILL TRAP ABRT BUS FPE USR1\
                                 SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS

            ns="sync"
            log "Launching: $1"
            eval "$1"
        )
        _es_m_f=$?
        shift
    done

    # It there were any 'sync', 'async' or 'halt' commands then switchs to
    # a 'process manager' mode. Otherwise, checks for a bare command 
    # in the command line (without quotation!)
    if (( halt_cmds_exist )) || (( async_cmds_exist )) || \
                                    (( sync_cmds_exist )); then
        debug "working in the 'process manager' mode"
        if (( async_cmds_exist )); then
            debug "wating for async process: ${!async_cmds_pids[*]}"
            # Waits for all background processes and exit with a status of
            # the last one or with 128+SIGNAL in case of getting a signal
            ${_wait_bg_cmd} ${!async_cmds_pids[*]}
            _es_m_d=$?

            for _pid in ${!async_cmds_pids[*]}; do
                debug "reaped 'async/${_pid}' (exitcode=x): \
${async_cmds_pids[_pid]}"
            done
        fi

        if (( _es_m_d )); then
            # update an exit code only if one of background processes has failed
            _es_m_f=${_es_m_d}
        fi

        if [[ "${RC_WAIT_POLICY}" = "wait_forever" ]]; then
            log "The infinite loop! To stop, press <Ctrl+C> or send SIGTERM..."
            run -p sleep infinity
        fi
    else
        debug  "looking for a 'bare' command..."      
        if [[ -n "$*" ]]; then
            ns="bare"
            log "handing over the execution to: $@"
            exec "$@"
        fi
    fi

    return ${_es_m_f}
}

main_exit_hook() {
    local _pid _cpids _file _cmd _es_mtt_h=0 _term_timeout=5

    # If it fails in the 'boot' stage, it appears here with 'set -e'.
    # So, reset to +e again
    set +e
    trap 'true' ERR

    log "Trying to terminate sub-processes..."
    for _pid in ${!async_cmds_pids[*]}; do
        if run -p ps -p ${_pid} &> /dev/null; then
            log "terminating the child process <pid=${_pid}>"

            # Removes all unexpected sub-processes
            _cpids="$(run -p pgrep -P ${_pid} -d,)"
            run kill -TERM ${_pid} $(echo "${_cpids}" | tr ',' ' ') &> /dev/null

            while run -p ps -p ${_pid},${_cpids} &> /dev/null && \
                  (( _term_timeout ))
            do
                run -p sleep 1
                (( _term_timeout-- ))
            done

            if run -p ps -p ${_pid},${_cpids} &>/dev/null; then
                run kill -KILL ${_pid} $(run echo "${_cpids}" | \
                                         run -p tr ',' ' ') &> /dev/null
            fi
        fi
    done

    debug "removing all unexpected sub-processes"
    run -p pkill -KILL -P ${MAIN_PID} &> /dev/null || true

    # --- 'halt' stage
    if (( boot_stage_left )); then
        debug "looking for 'halt' scripts..."
        # Checks for shutdown tasks in files (sequentially)
        for _file in $(run -p ls ${work_dir}/trc.halt.* \
                              ${work_dir}/trc.d/halt.* 2>/dev/null || true); do
            halt_cmds_exist=1
            (
                set -e # Exit on errors in a sub-shell
                ns="halt"
                log "Launching: ${_file}"
                . ${_file}
            )
            _es_mtt_h=$?
            log "Exiting (exitcode=${_es_mtt_h}): ${_file}"
        done

        # Runs shutdown tasks from the command line if any
        for _cmd in "${halt_cmds[@]}"; do
            (
                set -e # Exit on errors in the sub-shell

                ns="halt"
                log "Launching: ${_cmd}"
                eval "${_cmd}"
            )
            _es_mtt_h=$?
            log "Exiting (exitcode=${_es_mtt_h}): ${_cmd}"
        done    
    fi 

    if (( halt_cmds_exist )); then
        main_exit_code=${_es_mtt_h}
    fi

    log "Exited (exitcode=${main_exit_code})"
    exit ${main_exit_code}
}

sub_exit_hook() {
    set +e # do not stop on errors

    local _rc=$1 # Getting the exit code for a logging purpose only
    shift

    log "Exiting (exitcode=${_rc}): $@"

    if [[ "${RC_WAIT_POLICY}" = "wait_any" ]]; then 
        # If it's exiting from a background process and there is no need
        # to wait other processes, let's stop the main shell
        if run -p ps -p ${MAIN_PID} &> /dev/null; then
            debug "terminating the main process <pid=${MAIN_PID}>"
            run kill -TERM ${MAIN_PID} &> /dev/null
        fi
    fi

    exit ${_rc}
}

check_ver_usage() {
    case "$1" in
        -v|--version) print_version ;;
        -h|--help)    print_usage ;;
         *)           : ;;
    esac
}

check_req_bins() {
    local _cmd

    for _cmd in "$@"; do
        if ! run -v ${_cmd} &> /dev/null; then
            die "There is no the required command: ${_cmd}"
        fi
    done
}

print_usage() {
    local _self="$0"

    run echo "Usage:"
    run echo " ${_self} [[-h|--help]|[-v|--version]] \\"
    run echo "       [-w|--workdir 'dir'] \\"
    run echo "       [-B 'cmds' [...]] \\"
    run echo "       [-H 'cmds' [...]] \\"
    run echo "       [-D 'cmds' [...]] \\"
    run echo "       [-F 'cmds' [...]] \\"
    run echo "       [bare_cmd [args]]"
    run echo ""
    run echo "Examples:"
    run echo " $ ${_self} -B 'name=\$(id -un); echo booting...' \\"
    run echo "       -H 'echo halting...' \\"
    run echo "       -F 'echo Hello, \${name}!'"
    run echo ""
    run echo " $ RC_VERBOSE=true \\"
    run echo "   ${_self} -F 'echo -n \"Hello \"; echo World'"
    run echo ""
    run echo " $ ${_self} --workdir /opt/app"
    exit 0
}

print_version() {
    run echo "trc (TrivialRC) $trc_version"
    exit 0
}

run() {
    builtin command "$@"
}

say() {
    if [[ "${RC_VERBOSE}" = "true" ]]; then
        run echo "$@"
    fi
}

log() {
    say "$(iso_time) ${SELF_NAME} [${ns}/${BASHPID}]: $@"
}

warn() {
    log "$@" >&2
}

err() {
    warn "$@"
    exit 1
}

die() {
    say "$@" >&2
    exit 1
}

debug() {
    if [[ "${RC_VERBOSE_EXTRA}" = "true" ]]; then
        log " - $@"
    fi
}

iso_time() {
    run -p date '+%Y-%m-%d %H:%M:%S'
}

main "$@"
